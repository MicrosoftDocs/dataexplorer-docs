---
title:  make-series operator
description: Learn how to use the make-series operator to create a series of specified aggregated values along a specified axis. 
ms.reviewer: alexans
ms.topic: reference
ms.date: 01/03/2023
ms.localizationpriority: high
---
# make-series operator

Create series of specified aggregated values along a specified axis.

## Syntax

*T* `| make-series` [*MakeSeriesParameters*]
      [*Column* `=`] *Aggregation* [`default` `=` *DefaultValue*] [`,` ...]
    `on` *AxisColumn* [`from` *start*] [`to` *end*] `step` *step*
    [`by`
      [*Column* `=`] *GroupExpression* [`,` ...]]

[!INCLUDE [syntax-conventions-note](../../includes/syntax-conventions-note.md)]

## Parameters

| Name | Type | Required | Description |
|--|--|--|--|
|*Column*| `string` | | The name for the result column. Defaults to a name derived from the expression.|
|*DefaultValue* | scalar | | A default value to use instead of absent values. If there's no row with specific values of *AxisColumn* and *GroupExpression*, then the corresponding element of the array will be assigned a *DefaultValue*. Default is 0.|
|*Aggregation*| `string` |  :heavy_check_mark: | A call to an [aggregation function](make-series-operator.md#list-of-aggregation-functions), such as `count()` or `avg()`, with column names as arguments. See the [list of aggregation functions](make-series-operator.md#list-of-aggregation-functions). Only aggregation functions that return numeric results can be used with the `make-series` operator.|
|*AxisColumn*| `string` |  :heavy_check_mark: | The column by which the series will be ordered. Usually the column values will be of type `datetime` or `timespan` but all numeric types are accepted.|
|*start* | scalar |  :heavy_check_mark: | The low bound value of the *AxisColumn* for each of the series to be built. If *start* is not specified, it will be the first bin, or step, that has data in each series.|
|*end*| scalar|  :heavy_check_mark: | The high bound non-inclusive value of the *AxisColumn*. The last index of the time series is smaller than this value and will be *start* plus integer multiple of *step* that is smaller than *end*. If *end* is not specified, it will be the upper bound of the last bin, or step, that has data per each series.|
|*step*| scalar |  :heavy_check_mark: | The difference, or bin size, between two consecutive elements of the *AxisColumn* array. For a list of possible time intervals, see [timespan](./scalar-data-types/timespan.md).|
|*GroupExpression* | | |An expression over the columns that provides a set of distinct values. Typically it's a column name that already provides a restricted set of values. |
|*MakeSeriesParameters*| | | Zero or more space-separated parameters in the form of *Name* `=` *Value* that control the behavior. See [supported make series parameters](#supported-make-series-parameters).|

> [!NOTE]
> The *start*, *end*, and *step* parameters are used to build an array of *AxisColumn* values. The array consists of values between *start* and *end*, with the *step* value representing the difference between one array element to the next. All *Aggregation* values are ordered respectively to this array.

### Supported make series parameters

|Name|Description|
|--|--|
|`kind` |Produces default result when the input of make-series operator is empty. Value: `nonempty`|   
|`hint.shufflekey=<key>` |The `shufflekey` query shares the query load on cluster nodes, using a key to partition data. See [shuffle query](shuffle-query.md) |  

> [!NOTE]
>
> The arrays generated by make-series are limited to 1048576 values (2^20). Trying to generate a larger array with make-series would result in either an error or a truncated array.

**Alternate Syntax**

*T* `| make-series`
      [*Column* `=`] *Aggregation* [`default` `=` *DefaultValue*] [`,` ...]
    `on` *AxisColumn* `in` `range(`*start*`,` *stop*`,` *step*`)`
    [`by`
      [*Column* `=`] *GroupExpression* [`,` ...]]

The generated series from the alternate syntax differs from the main syntax in two aspects:

* The *stop* value is inclusive.
* Binning the index axis is generated with bin() and not bin_at(), which means that *start* may not be included in the generated series.

It's recommended to use the main syntax of make-series and not the alternate syntax.

## Returns

The input rows are arranged into groups having the same values of the `by` expressions and the `bin_at(`*AxisColumn*`,`*step*`,`*start*`)` expression. Then the specified aggregation functions are computed over each group, producing a row for each group. The result contains the `by` columns, *AxisColumn* column and also at least one column for each computed aggregate. (Aggregations over multiple columns or non-numeric results aren't supported.)

This intermediate result has as many rows as there are distinct combinations of `by` and `bin_at(`*AxisColumn*`,`*step*`,`*start*`)` values.

Finally the rows from the intermediate result arranged into groups having the same values of the `by` expressions and all aggregated values are arranged into arrays (values of `dynamic` type). For each aggregation, there's one column containing its array with the same name. The last column is an array containing the values of *AxisColumn* binned according to the specified *step*.

> [!NOTE]
>
> Although you can provide arbitrary expressions for both the aggregation and grouping expressions, it's more efficient to use simple column names.

## List of aggregation functions

|Function|Description|
|--------|-----------|
|[avg()](avg-aggfunction.md)|Returns an average value across the group|
|[avgif()](avgif-aggregation-function.md)|Returns an average with the predicate of the group|
|[count()](count-aggregation-function.md)|Returns a count of the group|
|[countif()](countif-aggregation-function.md)|Returns a count with the predicate of the group|
|[dcount()](dcount-aggfunction.md)|Returns an  approximate distinct count of the group elements|
|[dcountif()](dcountif-aggregation-function.md)|Returns an approximate distinct count with the predicate of the group|
|[max()](max-aggregation-function.md)|Returns the maximum value across the group|
|[maxif()](maxif-aggregation-function.md)|Returns the maximum value with the predicate of the group|
|[min()](min-aggregation-function.md)|Returns the minimum value across the group|
|[minif()](minif-aggregation-function.md)|Returns the minimum value with the predicate of the group|
|[percentile()](percentiles-aggregation-function.md)|Returns the percentile value across the group|
|[take_any()](take-any-aggregation-function.md)|Returns a random non-empty value for the group|
|[stdev()](stdev-aggregation-function.md)|Returns the standard deviation across the group|
|[sum()](sum-aggregation-function.md)|Returns the sum of the elements within the group|
|[sumif()](sumif-aggregation-function.md)|Returns the sum of the elements with the predicate of the group|
|[variance()](variance-aggregation-function.md)|Returns the variance across the group|

## List of series analysis functions

|Function|Description|
|--------|-----------|
|[series_fir()](series-fir-function.md)|Applies [Finite Impulse Response](https://en.wikipedia.org/wiki/Finite_impulse_response) filter|
|[series_iir()](series-iir-function.md)|Applies [Infinite Impulse Response](https://en.wikipedia.org/wiki/Infinite_impulse_response) filter|
|[series_fit_line()](series-fit-line-function.md)|Finds a straight line that is the best approximation of the input|
|[series_fit_line_dynamic()](series-fit-line-dynamic-function.md)|Finds a line that is the best approximation of the input, returning dynamic object|
|[series_fit_2lines()](series-fit-2lines-function.md)|Finds two lines that are the best approximation of the input|
|[series_fit_2lines_dynamic()](series-fit-2lines-dynamic-function.md)|Finds two lines that are the best approximation of the input, returning dynamic object|
|[series_outliers()](series-outliers-function.md)|Scores anomaly points in a series|
|[series_periods_detect()](series-periods-detect-function.md)|Finds the most significant periods that exist in a time series|
|[series_periods_validate()](series-periods-validate-function.md)|Checks whether a time series contains periodic patterns of given lengths|
|[series_stats_dynamic()](series-stats-dynamic-function.md)|Return multiple columns with the common statistics (min/max/variance/stdev/average)|
|[series_stats()](series-stats-function.md)|Generates a dynamic value with the common statistics (min/max/variance/stdev/average)|

For a complete list of series analysis functions, see: [Series processing functions](scalar-functions.md#series-processing-functions)

## List of series interpolation functions

|Function|Description|
|--------|-----------|
|[series_fill_backward()](series-fill-backward-function.md)|Performs backward fill interpolation of missing values in a series|
|[series_fill_const()](series-fill-const-function.md)|Replaces missing values in a series with a specified constant value|
|[series_fill_forward()](series-fill-forward-function.md)|Performs forward fill interpolation of missing values in a series|
|[series_fill_linear()](series-fill-linear-function.md)|Performs linear interpolation of missing values in a series|

* Note: Interpolation functions by default assume `null` as a missing value. Therefore specify `default=`*double*(`null`) in `make-series` if you intend to use interpolation functions for the series.

## Examples
  
 A table that shows arrays of the numbers and average prices of each fruit from each supplier ordered by the timestamp with specified range. There's a row in the output for each distinct combination of fruit and supplier. The output columns show the fruit, supplier, and arrays of: count, average, and the whole timeline (from 2016-01-01 until 2016-01-10). All arrays are sorted by the respective timestamp and all gaps are filled with default values (0 in this example). All other input columns are ignored.
  
```kusto
T | make-series PriceAvg=avg(Price) default=0
on Purchase from datetime(2016-09-10) to datetime(2016-09-13) step 1d by Supplier, Fruit
```

:::image type="content" source="media/make-seriesoperator/make-series.png" alt-text="Three tables. The first lists raw data, the second has only distinct supplier-fruit-date combinations, and the third contains the make-series results.":::  

> [!div class="nextstepaction"]
> <a href="https://dataexplorer.azure.com/clusters/help/databases/Samples?query=H4sIAAAAAAAAA3WSwW7DIAyG73kKHxMpkWxo0jRT34JbtQNbvSkaNBWgnvbwBZH1MIGEkOzvN7+FbTjAVQd9TlfQH4bbsFr2Qdv7EnOcoh4sB7d+LuBYm665NAB/rBVI00BikKRwWhC7Hkbs/ymOA1I8kR3KSEQky0jWq6RCmS2nsmCMaK4gRXI5pFqqGE9142O93bluOStBud2K4BSRqCBFItcSFRWECsf9//vm/a0xcbTrLbB7aANnoGtO+VQV49J4soJrCsKoSIvS/ILVPzx4dit70I/vNm9IB9sNXgsEX26zu2HY9nd94Purryf8i1rafwIAAA==" target="_blank">Run the query</a>

```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| make-series avg(metric) on timestamp from stime to etime step interval 
```
  
|avg_metric|timestamp|
|---|---|
|[ 4.0, 3.0, 5.0, 0.0, 10.5, 4.0, 3.0, 8.0, 6.5 ]|[ "2017-01-01T00:00:00.0000000Z", "2017-01-02T00:00:00.0000000Z", "2017-01-03T00:00:00.0000000Z", "2017-01-04T00:00:00.0000000Z", "2017-01-05T00:00:00.0000000Z", "2017-01-06T00:00:00.0000000Z", "2017-01-07T00:00:00.0000000Z", "2017-01-08T00:00:00.0000000Z", "2017-01-09T00:00:00.0000000Z" ]|  

When the input to `make-series` is empty, the default behavior of `make-series` produces an empty result.

> [!div class="nextstepaction"]
> <a href="https://dataexplorer.azure.com/clusters/help/databases/Samples?query=H4sIAAAAAAAAA3WSwW6DMAyG7zyFjyDBZCeFMibeIrdph6y4E1oCFbg97eEXFLZJE5GiKPb3O7+V2LHAYMX22yb23XEuo+dVrL91IcdbVIJnWcZLBwtbV2SvGcAPyxVSU5GqNBlsOsSihBrLf4pzhRRWYKdjpALSx0inq7RBHS2bY0EdUJtAhnR32mopYdykjc/pdtu0ZWsUxXYTgueAVAIZUrGW6FBBaLDe37/M3l4yF752nISXh3XQAw0xtW5VIT76nqjglIIwKLZByb7AjX4UwHDy9pOrlZeRV7CPjzzOSgEDX+3dSU9PCPMEv2MF12X2exsy726r8O2v23DrZb5P8g2FvL+MngIAAA==" target="_blank">Run the query</a>

```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| take 0
| make-series avg(metric) default=1.0 on timestamp from stime to etime step interval 
| count 
```

**Output**

|Count|
|---|
|0|

Using `kind=nonempty` in `make-series` will produce a non-empty result of the default values:

> [!div class="nextstepaction"]
> <a href="https://dataexplorer.azure.com/clusters/help/databases/Samples?query=H4sIAAAAAAAAA3WSwWqEMBCG7z7FHFfQMmNW11p8i9xKD2mdLWETFZ0uFPrwjcTuoRgIITPfP/xDZhwLDEZMv11i3h2fxHpexfi5CzneogI8y2I/OljYuDx7zQD+2KlCakqqSkUamw4xL6DG4p/iUiKFE9j5GFUBqWOk0lVKo4qWzbGgDqhNIE2qO2+1lDBu0saXdLtt2rLVFcV2E4LngKoE0lTFWqJDBaHGev//Int7yVwYrR2Fl7tx0AMNMbVuVSE+Gk9UcEpBGBTbomQ/4Ky3Ahhe3ty4XHmxvMLNjkM/TiP7Wb7B3D9PcXNyGPhqvpz09IQwjfBYMrguk9+bkmn3XoXnR++/5AUDOqMCAAA=" target="_blank">Run the query</a>

```kusto
let data=datatable(timestamp:datetime, metric: real)
[
  datetime(2016-12-31T06:00), 50,
  datetime(2017-01-01), 4,
  datetime(2017-01-02), 3,
  datetime(2017-01-03), 4,
  datetime(2017-01-03T03:00), 6,
  datetime(2017-01-05), 8,
  datetime(2017-01-05T13:40), 13,
  datetime(2017-01-06), 4,
  datetime(2017-01-07), 3,
  datetime(2017-01-08), 8,
  datetime(2017-01-08T21:00), 8,
  datetime(2017-01-09), 2,
  datetime(2017-01-09T12:00), 11,
  datetime(2017-01-10T05:00), 5,
];
let interval = 1d;
let stime = datetime(2017-01-01);
let etime = datetime(2017-01-10);
data
| take 0
| make-series kind=nonempty avg(metric) default=1.0 on timestamp from stime to etime step interval 
```

**Output**

|avg_metric|timestamp|
|---|---|
|[<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0,<br>  1.0<br>]|[<br>  "2017-01-01T00:00:00.0000000Z",<br>  "2017-01-02T00:00:00.0000000Z",<br>  "2017-01-03T00:00:00.0000000Z",<br>  "2017-01-04T00:00:00.0000000Z",<br>  "2017-01-05T00:00:00.0000000Z",<br>  "2017-01-06T00:00:00.0000000Z",<br>  "2017-01-07T00:00:00.0000000Z",<br>  "2017-01-08T00:00:00.0000000Z",<br>  "2017-01-09T00:00:00.0000000Z"<br>]|
